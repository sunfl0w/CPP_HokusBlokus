# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _Blokus
else:
    import _Blokus

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Blokus.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _Blokus.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _Blokus.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _Blokus.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _Blokus.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _Blokus.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _Blokus.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _Blokus.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _Blokus.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _Blokus.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _Blokus.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _Blokus.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _Blokus.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _Blokus.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _Blokus.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _Blokus.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _Blokus.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _Blokus:
_Blokus.SwigPyIterator_swigregister(SwigPyIterator)

class Logic(object):
    r"""This class defines some virtual methods for creating AIs for the game of Blokus."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructs a new Logic."""
        if self.__class__ == Logic:
            _self = None
        else:
            _self = self
        _Blokus.Logic_swiginit(self, _Blokus.new_Logic(_self, ))
    __swig_destroy__ = _Blokus.delete_Logic

    def GetNextMove(self, currentGameState: "GameState", ownPlayerID: "int") -> "HokusBlokus::Blokus::Move":
        r"""
        Gets the next Move to play. In this method the AI hast to be implemented.

        :type currentGameState: :py:class:`GameState`
        :param currentGameState: The GameState to get the next Move for.
        :type ownPlayerID: int
        :param ownPlayerID: The ID of the Player that is played by the AI.
        :rtype: :py:class:`Move`
        :return: The next move that should be played.
        """
        return _Blokus.Logic_GetNextMove(self, currentGameState, ownPlayerID)

    def OnGameEnd(self, winningPlayerID: "int") -> "void":
        r"""
        Will be executed when a game of Blokus ends.

        :type winningPlayerID: int
        :param winningPlayerID: The ID of the Player that won.
        """
        return _Blokus.Logic_OnGameEnd(self, winningPlayerID)
    def __disown__(self):
        self.this.disown()
        _Blokus.disown_Logic(self)
        return weakref.proxy(self)

# Register Logic in _Blokus:
_Blokus.Logic_swigregister(Logic)


def BenchmarkGPM(benchmarkTime: "unsigned int") -> "void":
    return _Blokus.BenchmarkGPM(benchmarkTime)
class BlokusClient(object):
    r"""This client class manages everything basically. It connects to the SC-Server, receives and sends messages, etc."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, logic: "Logic"):
        r"""
        Constructs a new BlokusClient with a Logic.

        :type logic: :py:class:`Logic`
        :param logic: The Logic that implements behaviour of the AI.
        """
        _Blokus.BlokusClient_swiginit(self, _Blokus.new_BlokusClient(logic))

    def Start(self, argc: "int") -> "void":
        r"""
        Starts the Client.

        :type argc: int
        :param argc: Number of console arguments.
        :type argv: string
        :param argv: Array of console Arguments.
        """
        return _Blokus.BlokusClient_Start(self, argc)
    __swig_destroy__ = _Blokus.delete_BlokusClient

# Register BlokusClient in _Blokus:
_Blokus.BlokusClient_swigregister(BlokusClient)

class TCP_Client(object):
    r"""A very basic client for managing TCP connections. It is tailored for use with the BlokusCLient."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructs a new TCP_Client."""
        _Blokus.TCP_Client_swiginit(self, _Blokus.new_TCP_Client())

    def ConnectWithIP(self, ipAddress: "std::string", port: "unsigned short") -> "void":
        r"""
        Connect to a server.

        :type ipAddress: string
        :param ipAddress: The address of the server.
        :type port: int
        :param port: The port of the server.
        """
        return _Blokus.TCP_Client_ConnectWithIP(self, ipAddress, port)

    def Disconnect(self) -> "void":
        r"""Disconnetcs from the server."""
        return _Blokus.TCP_Client_Disconnect(self)

    def ResolveHostnameToIPAddress(self, hostname: "std::string") -> "std::string":
        r"""
        Resolves a hostname to a valid IP address.

        :type hostname: string
        :param hostname: The hostname.
        :rtype: string
        :return: The IP address as a string.
        """
        return _Blokus.TCP_Client_ResolveHostnameToIPAddress(self, hostname)

    def SendMessage(self, message: "std::string") -> "void":
        r"""
        Sends a string to the server.

        :type message: string
        :param message: The string to send.
        """
        return _Blokus.TCP_Client_SendMessage(self, message)

    def ReadMessage(self) -> "std::string":
        r"""
        Receives a string from the server.

        :rtype: string
        :return: The string received from the server.
        """
        return _Blokus.TCP_Client_ReadMessage(self)
    __swig_destroy__ = _Blokus.delete_TCP_Client

# Register TCP_Client in _Blokus:
_Blokus.TCP_Client_swigregister(TCP_Client)

class SC_Message(object):
    r"""A class that represents SC_Messages."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructs a new and empty SC_Message.


        |

        *Overload 2:*

        Constructs a new SC_Message with given content and type.

        :type messageString: string
        :param messageString: The content of the SC_Message.
        :type messageType: SC_MessageType
        :param messageType: The type of the SC_Message.
        """
        _Blokus.SC_Message_swiginit(self, _Blokus.new_SC_Message(*args))

    def GetContent(self) -> "std::string":
        r"""
        Gets the content of the SC_Message.

        :rtype: string
        :return: The content of the SC_Message.
        """
        return _Blokus.SC_Message_GetContent(self)

    def GetMessageType(self) -> "SC_MessageType":
        r"""
        Gets the MessageType of the SC_Message.

        :rtype: SC_MessageType
        :return: he MessageType of the SC_Message.
        """
        return _Blokus.SC_Message_GetMessageType(self)
    __swig_destroy__ = _Blokus.delete_SC_Message

# Register SC_Message in _Blokus:
_Blokus.SC_Message_swigregister(SC_Message)

class SC_MessageConverter(object):
    r"""This class works on and with messages from the SC-Server."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructs a new SC_MessageConverter."""
        _Blokus.SC_MessageConverter_swiginit(self, _Blokus.new_SC_MessageConverter())

    def SplitInputMessagesIntoValidSC_Messages(self, inputStream: "std::string") -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message,std::allocator< HokusBlokus::Blokus::Communication::SC_Message > >":
        r"""
        Splits the incoming messages into SC_Messages.

        :type inputStream: string
        :param inputStream: The message received from the SC-Server.
        :rtype: std::vector< HokusBlokus::Blokus::Communication::SC_Message,std::allocator< HokusBlokus::Blokus::Communication::SC_Message > >
        :return: A vector of SC_Messages.
        """
        return _Blokus.SC_MessageConverter_SplitInputMessagesIntoValidSC_Messages(self, inputStream)

    def CreateProtocolMessage(self) -> "HokusBlokus::Blokus::Communication::SC_Message":
        r"""
        Creates a protocol SC_Message.

        :rtype: :py:class:`SC_Message`
        :return: A protocol SC_Message.
        """
        return _Blokus.SC_MessageConverter_CreateProtocolMessage(self)

    def CreateProtocolEndMessage(self) -> "HokusBlokus::Blokus::Communication::SC_Message":
        r"""
        Creates a protocol end SC_Message.

        :rtype: :py:class:`SC_Message`
        :return: A protocol end SC_Message.
        """
        return _Blokus.SC_MessageConverter_CreateProtocolEndMessage(self)

    def CreateJoinRequestMessage(self) -> "HokusBlokus::Blokus::Communication::SC_Message":
        r"""
        Creates a join request SC_Message.

        :rtype: :py:class:`SC_Message`
        :return: A join request SC_Message.
        """
        return _Blokus.SC_MessageConverter_CreateJoinRequestMessage(self)

    def CreateJoinReservedRequestMessage(self, reservationCode: "std::string const &") -> "HokusBlokus::Blokus::Communication::SC_Message":
        r"""
        Creates a join reserved SC_Message.

        :type reservationCode: string
        :param reservationCode: The reservation code.
        :rtype: :py:class:`SC_Message`
        :return: A join reserved SC_Message.
        """
        return _Blokus.SC_MessageConverter_CreateJoinReservedRequestMessage(self, reservationCode)

    def CreateMoveMessage(self, move: "Move", roomID: "std::string const &") -> "HokusBlokus::Blokus::Communication::SC_Message":
        r"""
        Create a move SCMessage.

        :type move: :py:class:`Move`
        :param move: The move.
        :type roomID: string
        :param roomID: The room ID.
        :rtype: :py:class:`SC_Message`
        :return: A move SCMessage.
        """
        return _Blokus.SC_MessageConverter_CreateMoveMessage(self, move, roomID)

    def GetPlayerIDFromWelcomeMessage(self, message: "SC_Message") -> "int":
        r"""
        Gets the Player ID from welcome SC_Messages.

        :type message: :py:class:`SC_Message`
        :param message: The welcome SC_Message.
        :rtype: int
        :return: Player ID in the welcome SC_Message.
        """
        return _Blokus.SC_MessageConverter_GetPlayerIDFromWelcomeMessage(self, message)

    def GetRoomIDFromJoinedMessage(self, message: "SC_Message") -> "std::string":
        r"""
        Gets the room ID from joined SC_Messages.

        :type message: :py:class:`SC_Message`
        :param message: The joined SC_Message.
        :rtype: string
        :return: The room ID.
        """
        return _Blokus.SC_MessageConverter_GetRoomIDFromJoinedMessage(self, message)

    def GetGameStateFromGameStateMessage(self, message: "SC_Message") -> "HokusBlokus::Blokus::GameState":
        r"""
        Gets the GameState from gameState SC_Messages.

        :type message: :py:class:`SC_Message`
        :param message: The gameState SC_Message.
        :rtype: :py:class:`GameState`
        :return: The GameState.
        """
        return _Blokus.SC_MessageConverter_GetGameStateFromGameStateMessage(self, message)

    def GetIDOfWinningPlayerFromResultMessage(self, message: "SC_Message") -> "int":
        r"""
        Gets the ID of the Player that won the game from result SC_Messages.

        :type message: :py:class:`SC_Message`
        :param message: The result SC_Message.
        :rtype: int
        :return: The ID of the Player that won the game.
        """
        return _Blokus.SC_MessageConverter_GetIDOfWinningPlayerFromResultMessage(self, message)
    __swig_destroy__ = _Blokus.delete_SC_MessageConverter

# Register SC_MessageConverter in _Blokus:
_Blokus.SC_MessageConverter_swigregister(SC_MessageConverter)

SC_MessageType_Protocol = _Blokus.SC_MessageType_Protocol
SC_MessageType_ProtocolEnd = _Blokus.SC_MessageType_ProtocolEnd
SC_MessageType_Welcome = _Blokus.SC_MessageType_Welcome
SC_MessageType_JoinRequest = _Blokus.SC_MessageType_JoinRequest
SC_MessageType_JoinRequestPrepared = _Blokus.SC_MessageType_JoinRequestPrepared
SC_MessageType_Joined = _Blokus.SC_MessageType_Joined
SC_MessageType_GameState = _Blokus.SC_MessageType_GameState
SC_MessageType_Move = _Blokus.SC_MessageType_Move
SC_MessageType_MoveRequest = _Blokus.SC_MessageType_MoveRequest
SC_MessageType_Left = _Blokus.SC_MessageType_Left
SC_MessageType_Result = _Blokus.SC_MessageType_Result
SC_MessageType_Error = _Blokus.SC_MessageType_Error
SC_MessageType_Undefined = _Blokus.SC_MessageType_Undefined
class BoundingRect(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Blokus.BoundingRect_swiginit(self, _Blokus.new_BoundingRect(*args))

    def GetMinBounds(self) -> "Vec2i const &":
        return _Blokus.BoundingRect_GetMinBounds(self)

    def SetMinBounds(self, minBounds: "Vec2i const &") -> "void":
        return _Blokus.BoundingRect_SetMinBounds(self, minBounds)

    def GetMaxBounds(self) -> "Vec2i const &":
        return _Blokus.BoundingRect_GetMaxBounds(self)

    def SetMaxBounds(self, maxBounds: "Vec2i const &") -> "void":
        return _Blokus.BoundingRect_SetMaxBounds(self, maxBounds)
    __swig_destroy__ = _Blokus.delete_BoundingRect

# Register BoundingRect in _Blokus:
_Blokus.BoundingRect_swigregister(BoundingRect)

class BoundingRectOptimizer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _Blokus.BoundingRectOptimizer_swiginit(self, _Blokus.new_BoundingRectOptimizer())

    def GetBoundingRect(self, color: "Color") -> "HokusBlokus::Blokus::Optimization::BoundingRect const &":
        return _Blokus.BoundingRectOptimizer_GetBoundingRect(self, color)

    def OptimizeBoundingRectOfColor(self, color: "Color", board: "Board") -> "void":
        return _Blokus.BoundingRectOptimizer_OptimizeBoundingRectOfColor(self, color, board)
    __swig_destroy__ = _Blokus.delete_BoundingRectOptimizer

# Register BoundingRectOptimizer in _Blokus:
_Blokus.BoundingRectOptimizer_swigregister(BoundingRectOptimizer)

class Board(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _Blokus.Board_swiginit(self, _Blokus.new_Board())

    def InitStartingBoard(self) -> "void":
        return _Blokus.Board_InitStartingBoard(self)

    def GetBitmask(self, color: "Color") -> "std::bitset< 484 > &":
        return _Blokus.Board_GetBitmask(self, color)

    def SetBitmask(self, color: "Color", bitmask: "std::bitset< 484 >") -> "void":
        return _Blokus.Board_SetBitmask(self, color, bitmask)

    def Draw(self) -> "std::string":
        return _Blokus.Board_Draw(self)
    __swig_destroy__ = _Blokus.delete_Board

# Register Board in _Blokus:
_Blokus.Board_swigregister(Board)

Color_BLUE = _Blokus.Color_BLUE
Color_YELLOW = _Blokus.Color_YELLOW
Color_RED = _Blokus.Color_RED
Color_GREEN = _Blokus.Color_GREEN

def ColorToInt(color: "HokusBlokus::Blokus::Color") -> "int":
    return _Blokus.ColorToInt(color)

def ColorToString(color: "HokusBlokus::Blokus::Color") -> "std::string":
    return _Blokus.ColorToString(color)

def IntToColor(value: "int") -> "HokusBlokus::Blokus::Color":
    return _Blokus.IntToColor(value)
class GameState(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _Blokus.GameState_swiginit(self, _Blokus.new_GameState())

    def InitStartingGameState(self) -> "void":
        return _Blokus.GameState_InitStartingGameState(self)

    def GetBoard(self) -> "HokusBlokus::Blokus::Board &":
        return _Blokus.GameState_GetBoard(self)

    def GetCurrentColor(self) -> "HokusBlokus::Blokus::Color":
        return _Blokus.GameState_GetCurrentColor(self)

    def GetCurrentPlayer(self) -> "Player &":
        return _Blokus.GameState_GetCurrentPlayer(self)

    def GetPlayerWithColor(self, color: "HokusBlokus::Blokus::Color") -> "Player &":
        return _Blokus.GameState_GetPlayerWithColor(self, color)

    def GetPerformedMoves(self) -> "std::vector< Move,std::allocator< HokusBlokus::Blokus::Move > > &":
        return _Blokus.GameState_GetPerformedMoves(self)

    def GetLastPerfromedMove(self) -> "Move &":
        return _Blokus.GameState_GetLastPerfromedMove(self)

    def SetLastPerformedMove(self, move: "Move") -> "void":
        return _Blokus.GameState_SetLastPerformedMove(self, move)

    def GetTurn(self) -> "int":
        return _Blokus.GameState_GetTurn(self)

    def SetTurn(self, turn: "int") -> "void":
        return _Blokus.GameState_SetTurn(self, turn)

    def GetStartingPieceShape(self) -> "PieceShape":
        return _Blokus.GameState_GetStartingPieceShape(self)

    def SetStartingPieceShape(self, pieceShape: "PieceShape") -> "void":
        return _Blokus.GameState_SetStartingPieceShape(self, pieceShape)

    def GetPossibleMoves(self) -> "std::vector< Move,std::allocator< HokusBlokus::Blokus::Move > >":
        return _Blokus.GameState_GetPossibleMoves(self)

    def PerformMove(self, move: "Move const &") -> "void":
        return _Blokus.GameState_PerformMove(self, move)

    def UndoLastMove(self) -> "void":
        return _Blokus.GameState_UndoLastMove(self)

    def IsGameOver(self) -> "bool":
        return _Blokus.GameState_IsGameOver(self)

    def Draw(self) -> "std::string":
        return _Blokus.GameState_Draw(self)
    __swig_destroy__ = _Blokus.delete_GameState

# Register GameState in _Blokus:
_Blokus.GameState_swigregister(GameState)

MaskType_Shape = _Blokus.MaskType_Shape
MaskType_Corner = _Blokus.MaskType_Corner
MaskType_Edge = _Blokus.MaskType_Edge

def MaskTypeToInt(maskType: "HokusBlokus::Blokus::MaskType") -> "int":
    return _Blokus.MaskTypeToInt(maskType)

def IntToMaskType(value: "int") -> "HokusBlokus::Blokus::MaskType":
    return _Blokus.IntToMaskType(value)
class Move(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Blokus.Move_swiginit(self, _Blokus.new_Move(*args))

    def __eq__(self, other: "Move") -> "bool":
        return _Blokus.Move___eq__(self, other)

    def __ne__(self, other: "Move") -> "bool":
        return _Blokus.Move___ne__(self, other)

    def GetDestination(self) -> "Vec2i const &":
        return _Blokus.Move_GetDestination(self)

    def GetPieceShape(self) -> "PieceShape":
        return _Blokus.Move_GetPieceShape(self)

    def GetColor(self) -> "HokusBlokus::Blokus::Color":
        return _Blokus.Move_GetColor(self)

    def GetMoveType(self) -> "MoveType":
        return _Blokus.Move_GetMoveType(self)

    def GetComplementNumber(self) -> "int":
        return _Blokus.Move_GetComplementNumber(self)
    __swig_destroy__ = _Blokus.delete_Move

# Register Move in _Blokus:
_Blokus.Move_swigregister(Move)

MoveType_SetMove = _Blokus.MoveType_SetMove
MoveType_SkipMove = _Blokus.MoveType_SkipMove
MoveType_PassMove = _Blokus.MoveType_PassMove
class Piece(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pieceBitmaskComplements: "std::vector< PieceBitmaskComplement,std::allocator< HokusBlokus::Blokus::PieceBitmaskComplement > >"):
        _Blokus.Piece_swiginit(self, _Blokus.new_Piece(pieceBitmaskComplements))

    def GetPieceBitmaskComplements(self) -> "std::vector< PieceBitmaskComplement,std::allocator< HokusBlokus::Blokus::PieceBitmaskComplement > > const &":
        return _Blokus.Piece_GetPieceBitmaskComplements(self)
    __swig_destroy__ = _Blokus.delete_Piece

# Register Piece in _Blokus:
_Blokus.Piece_swigregister(Piece)

class PieceBitmask(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Blokus.PieceBitmask_swiginit(self, _Blokus.new_PieceBitmask(*args))

    def __eq__(self, other: "PieceBitmask") -> "bool":
        return _Blokus.PieceBitmask___eq__(self, other)

    def GetBitmask(self) -> "std::bitset< 484 > const &":
        return _Blokus.PieceBitmask_GetBitmask(self)

    def GetMaskDimensions(self) -> "Vec2i const &":
        return _Blokus.PieceBitmask_GetMaskDimensions(self)

    def GetMaskType(self) -> "HokusBlokus::Blokus::MaskType":
        return _Blokus.PieceBitmask_GetMaskType(self)

    def Draw(self) -> "std::string":
        return _Blokus.PieceBitmask_Draw(self)
    __swig_destroy__ = _Blokus.delete_PieceBitmask

# Register PieceBitmask in _Blokus:
_Blokus.PieceBitmask_swigregister(PieceBitmask)

class PieceBitmaskComplement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Blokus.PieceBitmaskComplement_swiginit(self, _Blokus.new_PieceBitmaskComplement(*args))

    def __eq__(self, other: "PieceBitmaskComplement") -> "bool":
        return _Blokus.PieceBitmaskComplement___eq__(self, other)

    def GetBitmask(self, maskType: "HokusBlokus::Blokus::MaskType") -> "HokusBlokus::Blokus::PieceBitmask const &":
        return _Blokus.PieceBitmaskComplement_GetBitmask(self, maskType)

    def GetRotation(self) -> "PieceRotation":
        return _Blokus.PieceBitmaskComplement_GetRotation(self)

    def IsFlipped(self) -> "bool":
        return _Blokus.PieceBitmaskComplement_IsFlipped(self)
    __swig_destroy__ = _Blokus.delete_PieceBitmaskComplement

# Register PieceBitmaskComplement in _Blokus:
_Blokus.PieceBitmaskComplement_swigregister(PieceBitmaskComplement)

class PieceManager(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def Init(executionPath: "std::string const &") -> "void":
        return _Blokus.PieceManager_Init(executionPath)

    @staticmethod
    def GetPiece(pieceShape: "PieceShape") -> "HokusBlokus::Blokus::Piece &":
        return _Blokus.PieceManager_GetPiece(pieceShape)
    __swig_destroy__ = _Blokus.delete_PieceManager

# Register PieceManager in _Blokus:
_Blokus.PieceManager_swigregister(PieceManager)

def PieceManager_Init(executionPath: "std::string const &") -> "void":
    return _Blokus.PieceManager_Init(executionPath)

def PieceManager_GetPiece(pieceShape: "PieceShape") -> "HokusBlokus::Blokus::Piece &":
    return _Blokus.PieceManager_GetPiece(pieceShape)

PieceRotation_NONE = _Blokus.PieceRotation_NONE
PieceRotation_RIGHT = _Blokus.PieceRotation_RIGHT
PieceRotation_MIRROR = _Blokus.PieceRotation_MIRROR
PieceRotation_LEFT = _Blokus.PieceRotation_LEFT

def StringToPieceRotation(pieceRotationString: "std::string") -> "HokusBlokus::Blokus::PieceRotation":
    return _Blokus.StringToPieceRotation(pieceRotationString)

def PieceRotationToString(pieceRotation: "HokusBlokus::Blokus::PieceRotation") -> "std::string":
    return _Blokus.PieceRotationToString(pieceRotation)
PieceShape_MONOMINO = _Blokus.PieceShape_MONOMINO
PieceShape_DOMINO = _Blokus.PieceShape_DOMINO
PieceShape_TRIO_L = _Blokus.PieceShape_TRIO_L
PieceShape_TRIO_I = _Blokus.PieceShape_TRIO_I
PieceShape_TETRO_I = _Blokus.PieceShape_TETRO_I
PieceShape_TETRO_L = _Blokus.PieceShape_TETRO_L
PieceShape_TETRO_O = _Blokus.PieceShape_TETRO_O
PieceShape_TETRO_T = _Blokus.PieceShape_TETRO_T
PieceShape_TETRO_Z = _Blokus.PieceShape_TETRO_Z
PieceShape_PENTO_I = _Blokus.PieceShape_PENTO_I
PieceShape_PENTO_U = _Blokus.PieceShape_PENTO_U
PieceShape_PENTO_L = _Blokus.PieceShape_PENTO_L
PieceShape_PENTO_V = _Blokus.PieceShape_PENTO_V
PieceShape_PENTO_P = _Blokus.PieceShape_PENTO_P
PieceShape_PENTO_W = _Blokus.PieceShape_PENTO_W
PieceShape_PENTO_R = _Blokus.PieceShape_PENTO_R
PieceShape_PENTO_X = _Blokus.PieceShape_PENTO_X
PieceShape_PENTO_Z = _Blokus.PieceShape_PENTO_Z
PieceShape_PENTO_Y = _Blokus.PieceShape_PENTO_Y
PieceShape_PENTO_T = _Blokus.PieceShape_PENTO_T
PieceShape_PENTO_S = _Blokus.PieceShape_PENTO_S

def PieceShapeToInt(pieceShape: "HokusBlokus::Blokus::PieceShape") -> "int":
    return _Blokus.PieceShapeToInt(pieceShape)

def PieceShapeToString(pieceShape: "HokusBlokus::Blokus::PieceShape") -> "std::string":
    return _Blokus.PieceShapeToString(pieceShape)

def IntToPieceShape(value: "int") -> "HokusBlokus::Blokus::PieceShape":
    return _Blokus.IntToPieceShape(value)

def StringToPieceShape(pieceShapeString: "std::string") -> "HokusBlokus::Blokus::PieceShape":
    return _Blokus.StringToPieceShape(pieceShapeString)
class Player(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, color0: "HokusBlokus::Blokus::Color", color1: "HokusBlokus::Blokus::Color"):
        _Blokus.Player_swiginit(self, _Blokus.new_Player(color0, color1))

    def PopulateUndeployedPieces(self) -> "void":
        return _Blokus.Player_PopulateUndeployedPieces(self)

    def GetColors(self) -> "std::array< HokusBlokus::Blokus::Color,2 >":
        return _Blokus.Player_GetColors(self)

    def GetUndeployedPieceShapeIDs(self, color: "HokusBlokus::Blokus::Color") -> "std::vector< int,std::allocator< int > > const &":
        return _Blokus.Player_GetUndeployedPieceShapeIDs(self, color)

    def AddUndeployedPieceShape(self, color: "HokusBlokus::Blokus::Color", pieceShape: "HokusBlokus::Blokus::PieceShape") -> "void":
        return _Blokus.Player_AddUndeployedPieceShape(self, color, pieceShape)

    def RemoveUndeployedPieceShape(self, color: "HokusBlokus::Blokus::Color", pieceShape: "HokusBlokus::Blokus::PieceShape") -> "void":
        return _Blokus.Player_RemoveUndeployedPieceShape(self, color, pieceShape)
    __swig_destroy__ = _Blokus.delete_Player

# Register Player in _Blokus:
_Blokus.Player_swigregister(Player)

class Vec2i(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_Blokus.Vec2i_x_get, _Blokus.Vec2i_x_set)
    y = property(_Blokus.Vec2i_y_get, _Blokus.Vec2i_y_set)

    def __init__(self, *args):
        _Blokus.Vec2i_swiginit(self, _Blokus.new_Vec2i(*args))

    def __eq__(self, other: "Vec2i") -> "bool":
        return _Blokus.Vec2i___eq__(self, other)
    __swig_destroy__ = _Blokus.delete_Vec2i

# Register Vec2i in _Blokus:
_Blokus.Vec2i_swigregister(Vec2i)

class SC_Message_Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _Blokus.SC_Message_Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _Blokus.SC_Message_Vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _Blokus.SC_Message_Vector___bool__(self)

    def __len__(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::size_type":
        return _Blokus.SC_Message_Vector___len__(self)

    def __getslice__(self, i: "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::difference_type", j: "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::difference_type") -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message,std::allocator< HokusBlokus::Blokus::Communication::SC_Message > > *":
        return _Blokus.SC_Message_Vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _Blokus.SC_Message_Vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::difference_type", j: "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::difference_type") -> "void":
        return _Blokus.SC_Message_Vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _Blokus.SC_Message_Vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::value_type const &":
        return _Blokus.SC_Message_Vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _Blokus.SC_Message_Vector___setitem__(self, *args)

    def pop(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::value_type":
        return _Blokus.SC_Message_Vector_pop(self)

    def append(self, x: "SC_Message") -> "void":
        return _Blokus.SC_Message_Vector_append(self, x)

    def empty(self) -> "bool":
        return _Blokus.SC_Message_Vector_empty(self)

    def size(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::size_type":
        return _Blokus.SC_Message_Vector_size(self)

    def swap(self, v: "SC_Message_Vector") -> "void":
        return _Blokus.SC_Message_Vector_swap(self, v)

    def begin(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::iterator":
        return _Blokus.SC_Message_Vector_begin(self)

    def end(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::iterator":
        return _Blokus.SC_Message_Vector_end(self)

    def rbegin(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::reverse_iterator":
        return _Blokus.SC_Message_Vector_rbegin(self)

    def rend(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::reverse_iterator":
        return _Blokus.SC_Message_Vector_rend(self)

    def clear(self) -> "void":
        return _Blokus.SC_Message_Vector_clear(self)

    def get_allocator(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::allocator_type":
        return _Blokus.SC_Message_Vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _Blokus.SC_Message_Vector_pop_back(self)

    def erase(self, *args) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::iterator":
        return _Blokus.SC_Message_Vector_erase(self, *args)

    def __init__(self, *args):
        _Blokus.SC_Message_Vector_swiginit(self, _Blokus.new_SC_Message_Vector(*args))

    def push_back(self, x: "SC_Message") -> "void":
        return _Blokus.SC_Message_Vector_push_back(self, x)

    def front(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::value_type const &":
        return _Blokus.SC_Message_Vector_front(self)

    def back(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::value_type const &":
        return _Blokus.SC_Message_Vector_back(self)

    def assign(self, n: "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::size_type", x: "SC_Message") -> "void":
        return _Blokus.SC_Message_Vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _Blokus.SC_Message_Vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _Blokus.SC_Message_Vector_insert(self, *args)

    def reserve(self, n: "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::size_type") -> "void":
        return _Blokus.SC_Message_Vector_reserve(self, n)

    def capacity(self) -> "std::vector< HokusBlokus::Blokus::Communication::SC_Message >::size_type":
        return _Blokus.SC_Message_Vector_capacity(self)
    __swig_destroy__ = _Blokus.delete_SC_Message_Vector

# Register SC_Message_Vector in _Blokus:
_Blokus.SC_Message_Vector_swigregister(SC_Message_Vector)

class Move_Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _Blokus.Move_Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _Blokus.Move_Vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _Blokus.Move_Vector___bool__(self)

    def __len__(self) -> "std::vector< HokusBlokus::Blokus::Move >::size_type":
        return _Blokus.Move_Vector___len__(self)

    def __getslice__(self, i: "std::vector< HokusBlokus::Blokus::Move >::difference_type", j: "std::vector< HokusBlokus::Blokus::Move >::difference_type") -> "std::vector< HokusBlokus::Blokus::Move,std::allocator< HokusBlokus::Blokus::Move > > *":
        return _Blokus.Move_Vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _Blokus.Move_Vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< HokusBlokus::Blokus::Move >::difference_type", j: "std::vector< HokusBlokus::Blokus::Move >::difference_type") -> "void":
        return _Blokus.Move_Vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _Blokus.Move_Vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HokusBlokus::Blokus::Move >::value_type const &":
        return _Blokus.Move_Vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _Blokus.Move_Vector___setitem__(self, *args)

    def pop(self) -> "std::vector< HokusBlokus::Blokus::Move >::value_type":
        return _Blokus.Move_Vector_pop(self)

    def append(self, x: "Move") -> "void":
        return _Blokus.Move_Vector_append(self, x)

    def empty(self) -> "bool":
        return _Blokus.Move_Vector_empty(self)

    def size(self) -> "std::vector< HokusBlokus::Blokus::Move >::size_type":
        return _Blokus.Move_Vector_size(self)

    def swap(self, v: "Move_Vector") -> "void":
        return _Blokus.Move_Vector_swap(self, v)

    def begin(self) -> "std::vector< HokusBlokus::Blokus::Move >::iterator":
        return _Blokus.Move_Vector_begin(self)

    def end(self) -> "std::vector< HokusBlokus::Blokus::Move >::iterator":
        return _Blokus.Move_Vector_end(self)

    def rbegin(self) -> "std::vector< HokusBlokus::Blokus::Move >::reverse_iterator":
        return _Blokus.Move_Vector_rbegin(self)

    def rend(self) -> "std::vector< HokusBlokus::Blokus::Move >::reverse_iterator":
        return _Blokus.Move_Vector_rend(self)

    def clear(self) -> "void":
        return _Blokus.Move_Vector_clear(self)

    def get_allocator(self) -> "std::vector< HokusBlokus::Blokus::Move >::allocator_type":
        return _Blokus.Move_Vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _Blokus.Move_Vector_pop_back(self)

    def erase(self, *args) -> "std::vector< HokusBlokus::Blokus::Move >::iterator":
        return _Blokus.Move_Vector_erase(self, *args)

    def __init__(self, *args):
        _Blokus.Move_Vector_swiginit(self, _Blokus.new_Move_Vector(*args))

    def push_back(self, x: "Move") -> "void":
        return _Blokus.Move_Vector_push_back(self, x)

    def front(self) -> "std::vector< HokusBlokus::Blokus::Move >::value_type const &":
        return _Blokus.Move_Vector_front(self)

    def back(self) -> "std::vector< HokusBlokus::Blokus::Move >::value_type const &":
        return _Blokus.Move_Vector_back(self)

    def assign(self, n: "std::vector< HokusBlokus::Blokus::Move >::size_type", x: "Move") -> "void":
        return _Blokus.Move_Vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _Blokus.Move_Vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _Blokus.Move_Vector_insert(self, *args)

    def reserve(self, n: "std::vector< HokusBlokus::Blokus::Move >::size_type") -> "void":
        return _Blokus.Move_Vector_reserve(self, n)

    def capacity(self) -> "std::vector< HokusBlokus::Blokus::Move >::size_type":
        return _Blokus.Move_Vector_capacity(self)
    __swig_destroy__ = _Blokus.delete_Move_Vector

# Register Move_Vector in _Blokus:
_Blokus.Move_Vector_swigregister(Move_Vector)

class Bitmask_Complement_Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _Blokus.Bitmask_Complement_Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _Blokus.Bitmask_Complement_Vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _Blokus.Bitmask_Complement_Vector___bool__(self)

    def __len__(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::size_type":
        return _Blokus.Bitmask_Complement_Vector___len__(self)

    def __getslice__(self, i: "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::difference_type", j: "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::difference_type") -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement,std::allocator< HokusBlokus::Blokus::PieceBitmaskComplement > > *":
        return _Blokus.Bitmask_Complement_Vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _Blokus.Bitmask_Complement_Vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::difference_type", j: "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::difference_type") -> "void":
        return _Blokus.Bitmask_Complement_Vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _Blokus.Bitmask_Complement_Vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::value_type const &":
        return _Blokus.Bitmask_Complement_Vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _Blokus.Bitmask_Complement_Vector___setitem__(self, *args)

    def pop(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::value_type":
        return _Blokus.Bitmask_Complement_Vector_pop(self)

    def append(self, x: "PieceBitmaskComplement") -> "void":
        return _Blokus.Bitmask_Complement_Vector_append(self, x)

    def empty(self) -> "bool":
        return _Blokus.Bitmask_Complement_Vector_empty(self)

    def size(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::size_type":
        return _Blokus.Bitmask_Complement_Vector_size(self)

    def swap(self, v: "Bitmask_Complement_Vector") -> "void":
        return _Blokus.Bitmask_Complement_Vector_swap(self, v)

    def begin(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::iterator":
        return _Blokus.Bitmask_Complement_Vector_begin(self)

    def end(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::iterator":
        return _Blokus.Bitmask_Complement_Vector_end(self)

    def rbegin(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::reverse_iterator":
        return _Blokus.Bitmask_Complement_Vector_rbegin(self)

    def rend(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::reverse_iterator":
        return _Blokus.Bitmask_Complement_Vector_rend(self)

    def clear(self) -> "void":
        return _Blokus.Bitmask_Complement_Vector_clear(self)

    def get_allocator(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::allocator_type":
        return _Blokus.Bitmask_Complement_Vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _Blokus.Bitmask_Complement_Vector_pop_back(self)

    def erase(self, *args) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::iterator":
        return _Blokus.Bitmask_Complement_Vector_erase(self, *args)

    def __init__(self, *args):
        _Blokus.Bitmask_Complement_Vector_swiginit(self, _Blokus.new_Bitmask_Complement_Vector(*args))

    def push_back(self, x: "PieceBitmaskComplement") -> "void":
        return _Blokus.Bitmask_Complement_Vector_push_back(self, x)

    def front(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::value_type const &":
        return _Blokus.Bitmask_Complement_Vector_front(self)

    def back(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::value_type const &":
        return _Blokus.Bitmask_Complement_Vector_back(self)

    def assign(self, n: "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::size_type", x: "PieceBitmaskComplement") -> "void":
        return _Blokus.Bitmask_Complement_Vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _Blokus.Bitmask_Complement_Vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _Blokus.Bitmask_Complement_Vector_insert(self, *args)

    def reserve(self, n: "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::size_type") -> "void":
        return _Blokus.Bitmask_Complement_Vector_reserve(self, n)

    def capacity(self) -> "std::vector< HokusBlokus::Blokus::PieceBitmaskComplement >::size_type":
        return _Blokus.Bitmask_Complement_Vector_capacity(self)
    __swig_destroy__ = _Blokus.delete_Bitmask_Complement_Vector

# Register Bitmask_Complement_Vector in _Blokus:
_Blokus.Bitmask_Complement_Vector_swigregister(Bitmask_Complement_Vector)

class Int_Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _Blokus.Int_Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _Blokus.Int_Vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _Blokus.Int_Vector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _Blokus.Int_Vector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _Blokus.Int_Vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _Blokus.Int_Vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _Blokus.Int_Vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _Blokus.Int_Vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _Blokus.Int_Vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _Blokus.Int_Vector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _Blokus.Int_Vector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _Blokus.Int_Vector_append(self, x)

    def empty(self) -> "bool":
        return _Blokus.Int_Vector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _Blokus.Int_Vector_size(self)

    def swap(self, v: "Int_Vector") -> "void":
        return _Blokus.Int_Vector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _Blokus.Int_Vector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _Blokus.Int_Vector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _Blokus.Int_Vector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _Blokus.Int_Vector_rend(self)

    def clear(self) -> "void":
        return _Blokus.Int_Vector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _Blokus.Int_Vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _Blokus.Int_Vector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _Blokus.Int_Vector_erase(self, *args)

    def __init__(self, *args):
        _Blokus.Int_Vector_swiginit(self, _Blokus.new_Int_Vector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _Blokus.Int_Vector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _Blokus.Int_Vector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _Blokus.Int_Vector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _Blokus.Int_Vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _Blokus.Int_Vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _Blokus.Int_Vector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _Blokus.Int_Vector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _Blokus.Int_Vector_capacity(self)
    __swig_destroy__ = _Blokus.delete_Int_Vector

# Register Int_Vector in _Blokus:
_Blokus.Int_Vector_swigregister(Int_Vector)



